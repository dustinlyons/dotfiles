#+TITLE: Dustin Lyons' emacs configuration
#+OPTIONS: toc:nil h:4

Last exported:  {{{modification-time(%Y-%m-%d %H:%M)}}}

#+TOC: headlines 4

* Configuration   :emacs:
** About this file
This is my emacs config file. Yes, in emacs you can write configuration in the same way you would write a Google Doc and get away with it.

** Background
As of July 13, 2021, I'm a recent vim expact. What led me here, you may ask?

In late 2020, I discovered Roam and the movement behind networked notes, or "smart notes" aka Zettlekasten. I was writing in a style that made sense to my brain, and I was more focused on recording ideas for my future self to rediscover, instead of just being buried away in a folder. This was foundational as it enabled me to create more leverage.

However, these ideas weren't unique to Roam. I began to look at others, and I quickly found problem with the available tools on the market. I began to look at open source equivalents and found org-roam. Given vim's modal editing was foundational to my life many years ago, this gave me an excuse to make the leap over to kick the tires on _evil mode_ and test a new wn workflow. Once I peaked into everything emacs had to offer, I was hooked.

It's pretty clear that the vim vs emacs battle is over, and the real winner
is emacs with evil mode

** For the reader
For the reader, here are some useful facts to aid in your understanding of this configuration:

- The _t_ variable stands for _true_, and is used with _nil_ to form boolean operations.
- "Evil mode" is essentially vim, inside emacs. It's the best of both worlds.

:PROPERTIES:
:CUSTOM_ID: babel-init
:END:
<<babel-init>>

** Personal information
Just me!

#+NAME: personal-info
#+BEGIN_SRC emacs-lisp 
  (setq user-full-name "Dustin Lyons"
    user-mail-address "hello@dustinlyons.co")
#+END_SRC

** Starting up
Here's how we start:

#+NAME: startup
#+BEGIN_SRC emacs-lisp 
  ;; Turn off the splash screen
  (setq inhibit-startup-screen t)

  ;; CUSTOM FUNCTIONS, we load this file at the very end
  (setq custom-file "~/.emacs.d/local-config.org")
  (load custom-file t)
#+END_SRC

** Emacs initialization
*** Add package sources
This associates our package manager with the right source (MELPA).

#+NAME: package-sources
#+BEGIN_SRC emacs-lisp 
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
  (unless (assoc-default "nongnu" package-archives)
    (add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/") t))
#+END_SRC

*** Packages
Here we install some helpers and begin downloading some core packages.

**** Install straight.el with use-package
I configure straight.el to automatically fetch packages over git via use-package. I prefer git as it's easier to version any hacks.

#+NAME: straight-el
#+BEGIN_SRC emacs-lisp
  ;; use-package package provides common package import functions
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
  (require 'use-package)

  ;; This sets up straight.el, a git package manager
  (defvar bootstrap-version)
    (let ((bootstrap-file
	 (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	(bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
	  (url-retrieve-synchronously
	   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	   'silent 'inhibit-cookies)
	(goto-char (point-max))
	(eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Tells (use-package) to use straight.el to download packages
  ;; straight.el uses git packages, instead of the default bin files, which we like
  (setq straight-use-package-by-default t)
#+END_SRC

** Display options
*** Themes
Some my own, some from others.

#+NAME: themes
#+BEGIN_SRC emacs-lisp 
  (add-to-list 'custom-theme-load-path "~/.dotfiles/emacs/.emacs.d/themes")
  (load-theme 'dracula t)
#+END_SRC

*** Windows
**** Defaults
Sets some reasonable defaults.

#+NAME: windows-reasonable-defaults
#+BEGIN_SRC emacs-lisp 
  (setq use-dialog-box nil
      use-file-dialog nil
      cursor-type 'bar)
#+END_SRC

**** UI configuration
Turns off the various menu bars, they're quite ugly.

***** Fonts
#+BEGIN_SRC emacs-lisp 
(set-face-attribute 'default nil :font "Hack" :height 100)
#+END_SRC

***** Line numbers
These functions define vim-style relative line numbers.

#+NAME: line-numbers
#+BEGIN_SRC emacs-lisp 
  (global-linum-mode 1)
  (defvar my-linum-current-line-number 0)
  (setq linum-format 'my-linum-relative-line-numbers)

  ;; This fancy function handles the math behind relative line numbers
  (defun my-linum-relative-line-numbers (line-number)
  (let ((y (1+ (- line-number my-linum-current-line-number))))
      (propertize
      (number-to-string
	  (cond ((<= y 0) (abs (- y 2))) ((> y 0) y)))
	  'face 'linum)))

  (defadvice linum-update (around my-linum-update)
  (let ((my-linum-current-line-number (line-number-at-pos)))
      ad-do-it))

  ;; Turn it on
  (ad-activate 'linum-update)

  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
		  term-mode-hook
		  shell-mode-hook
		  eshell-mode-hook))
    (add-hook mode (lambda () (linum-mode 0)))) 
#+END_SRC

***** Modes
I like these window related minor modes.

#+NAME: windows-ui-settings
#+BEGIN_SRC emacs-lisp 
  ;; Turn off UI junk
  (column-number-mode)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

**** "Powerline
#+NAME: modeline
#+BEGIN_SRC emacs-lisp 
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1))
#+END_SRC

** Global modes
I like these modes.

#+NAME: global-modes
#+BEGIN_SRC emacs-lisp 
  (global-visual-line-mode t) ;; Wraps lines everywhere
  (line-number-mode t) ;; Line numbers in the gutter
  (show-paren-mode t) ;; Highlights parans for me
#+END_SRC

** Org mode
*** My productivity workflow
If you haven't heard of org mode, go watch [[https://www.youtube.com/watch?v=SzA2YODtgK4][this]] talk and come back when you are finished.

#+NAME::org-mode
#+BEGIN_SRC emacs-lisp 
(use-package org
  :defer t
  :config
    (setq org-edit-src-content-indentation 2
          org-hide-block-startup nil))
#+END_SRC


** Evil mode
*** Vim inside emacs
This is what makes emacs possible for me. All evil mode packages and related configuration.

#+NAME: evil-packages
#+BEGIN_SRC emacs-lisp 
  (use-package evil
    :init
    (setq evil-want-keybinding nil)
    :config
    (evil-mode 1))

  ;; Gives me vim bindings elsewhere in emacs
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  ;; Keybindings in org mode
 ;; (use-package evil-org
  ;;  :after org
   ;; :hook (org-mode . (lambda () evil-org-mode))
   ;; :config
   ;; (require 'evil-org-agenda)
   ;; (evil-org-agenda-set-keys))

  ;; Branching undo system
  (use-package undo-tree
    :after evil
    :diminish 
    :config
    (evil-set-undo-system 'undo-tree)
    (global-undo-tree-mode 1))

  ;; Undo/redo each motion
  (setq evil-want-fine-undo 'fine)
  ;; Use esc as cancel key everywhere
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+END_SRC

** Managing files
*** Fuzzy file finder
File finder and associated helpers that uses the minibuffer (the info window at the bottom).

#+NAME: file-finder
#+BEGIN_SRC emacs-lisp 
(use-package ivy
  :diminish
  :bind (("C-s" . swiper)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :init
  (ivy-mode 1)
  :config
  (setq ivy-use-virtual-buffers t)
  (setq ivy-wrap t)
  (setq ivy-count-format "(%d/%d) ")
  (setq enable-recursive-minibuffers t))

(use-package counsel
  :demand t
  :bind (("M-x" . counsel-M-x)
         ("C-x b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         ;; ("C-M-j" . counsel-switch-buffer)
         ("C-M-l" . counsel-imenu)
         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil)) ;; Don't start searches with ^
#+END_SRC

*** File types
**** Markdown mode
#+NAME::markdown-mode
#+BEGIN_SRC emacs-lisp 
  ;; This uses Github Flavored Markdown for README files
  (use-package markdown-mode
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
      ("\\.md\\'" . markdown-mode)
      ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

** Learning emacs
*** Indent org-babel source blocks
#+BEGIN_SRC emacs-lisp 
  (setq org-src-tab-acts-natively t)
#+END_SRC

*** Show real time key bindings
These packages may come and go, but ultimately aid in my understanding of emacs and emacslisp.

#+NAME: utility-packages
#+BEGIN_SRC emacs-lisp 
  ;; Gives me a fancy list of commands I run
  (use-package command-log-mode)
  (setq global-command-log-mode t)
  ;; TODO Install package that lets you define help screens for keymaps
#+END_SRC
